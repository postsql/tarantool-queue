{"google":"UA-22120502-1","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Tarantool-queue","tagline":"A set of Lua stored procedures for making a queue server out of Tarantool","body":"# Queue API description\r\n\r\nA Tarantool/Box instance can serve as a Queue Manager, along\r\nwith any other database work necessary.\r\n\r\nA single properly configured Tarantool/Box space can store any\r\nnumber of queues. Multiple spaces can be used as well - for\r\npartitioning or logical separation of queues.\r\n\r\nQueues support task priority. Priority value lays in the range\r\n[0, 255], with default value being 127. A higher value means higher\r\npriority, lower value - lower priority.\r\n\r\nEach queue has one (currently) associated *fiber* taking care of\r\nit. The fiber is started upon first access to the queue. The job\r\nof the fiber is to monitor orphaned tasks, as well as prune and\r\nclean the queue from obsolete tasks.\r\n\r\nTo configure a space supporting queues, use the following parameters:\r\n\r\n```cfg\r\nspace = [\r\n    {\r\n        enabled = 1,\r\n        index = [\r\n            {\r\n                type = \"TREE\",\r\n                unique = 1,\r\n                key_field = [\r\n                    {\r\n                        fieldno = 0,\r\n                        type = \"STR\"\r\n                    }\r\n                ]\r\n            },\r\n            {\r\n                type = \"TREE\",\r\n                unique = 0,\r\n                key_field = [\r\n                    {\r\n                        fieldno = 1,    # queue, aka tube\r\n                        type = \"STR\"\r\n                    },\r\n                    {\r\n                        fieldno = 2,    # status\r\n                        type = \"STR\"\r\n                    },\r\n                    {\r\n                        fieldno = 4,    # ipri\r\n                        type = \"STR\"\r\n                    },\r\n                    {\r\n                        fieldno = 5    # pri\r\n                        type = \"STR\"\r\n                    }\r\n                ]\r\n            },\r\n            {\r\n                type    = \"TREE\",\r\n                unique  = 0,\r\n                key_field = [\r\n                    {\r\n                        fieldno = 3,    # next_event\r\n                        type = \"NUM64\"\r\n                    }\r\n                ]\r\n            }\r\n        ]\r\n    }\r\n]\r\n```\r\n\r\nIt may also be desirable to tune server `readahead` configuration\r\nvariable if many consumers re-use the same socket for getting and\r\nacknowledging tasks.\r\n\r\nThe recommended value can be calculated as:\r\n\r\n```\r\n  consumers-per-socket * (256 + largest task size)\r\n```\r\n\r\nFor example, if the largest task size is 256 bytes, and average\r\nnumber of consumers per socket is 10, the recommended `readahead`\r\nvalue must be at least 51 200 bytes.\r\n\r\n## Terminology\r\n\r\n* *Consumer* - a process, taking and executing tasks\r\n* *Producer* - a process adding new tasks\r\n\r\n### Arguments of queue API functions\r\n\r\n* `space` (number) space id. To avoid confusion and broken statistics,\r\n  it's necessary to consistently use numbers to identify spaces,\r\n* `tube` (string) - queue name,\r\n* `delay` (number) - a delay between the moment a task is queued\r\n  and is executed, in seconds\r\n* `ttl` (number) - task time to live, in seconds. If `delay` is\r\n  given along with `ttl`, the effective task time to live is\r\n  increased by the amount of `delay`,\r\n* `ttr` (number) - task time to run, the maximal time allotted\r\n  to a consumer to execute a task, in seconds,\r\n* `pri` (number) - task priority [0..255],\r\n* `id` (string) - task id,\r\n* `timeout` (number) - timeout in seconds for the Queue API function.\r\n\r\n### Task states\r\n\r\n* `ready` - a task is ready for execution,\r\n* `delayed` - a task is awaiting task `delay` to expire, after\r\n   which it will become `ready`,\r\n* `taken` - a task is taken by a consumer and is being executed,\r\n* `done` - a task is complete (but not deleted, since the consumer\r\n   called `done` rather than `ack`),\r\n* `buried` - a task is neither ready nor taken nor complete, it's\r\n   excluded (perhaps temporarily) from the list of tasks for\r\n   execution, but not deleted.\r\n\r\n### The format of task tuple\r\n\r\nQueue API functions, such as `put`, `take`, return a task.\r\nThe task consists of the following fields:\r\n\r\n1. `id` (string) - task identifier\r\n1. `tube` (string) - queue identifier\r\n1. `status` (string) - task status\r\n1. task data (all fields passed into `put`/`urgent` when\r\n   the task was created)\r\n\r\n## API\r\n\r\n### Producer\r\n\r\n#### queue.put(space, tube, delay, ttl, ttr, pri, ...)\r\n\r\nEnqueue a task. Returns a tuple, representing the new task.\r\nThe list of fields with task data is optional.\r\n\r\n#### queue.urgent(space, tube, delay, ttl, ttr, pri, ...)\r\n\r\nEnqueue a task. The task will get the highest priority.\r\nIf `delay` is not zero, the function is equivalent to `put`.\r\n\r\n### Consumer\r\n\r\n#### queue.take(space, tube, timeout)\r\n\r\nIf there are tasks in the queue `ready` for execution,\r\ntake the highest-priority task.\r\nOtherwise, wait for a `ready` task to appear in the queue, and, as\r\nsoon as it appears, mark it as `taken` and return to the consumer.\r\nIf there is a `timeout`, and the task doesn't appear until the\r\ntimeout expires, returns nil. If timeout is not given, waits\r\nindefinitely.\r\n\r\nAll the time while the consumer is working on a task, it must keep\r\nthe connection to the server open. If a connection disappears while\r\nthe consumer is still working on a task, the task is put back on the\r\n`ready` list.\r\n\r\n#### queue.ack(space, id)\r\n\r\nConfirm completion of a task. Before marking a task as complete,\r\nthis function verifies that:\r\n\r\n* the task is `taken` and\r\n* the consumer that is confirming the task is the one which took it\r\n\r\nConsumer identity is established using a session identifier. In\r\nother words, the task must be confirmed by the same connection\r\nwhich took it. If verification fails, the function returns an\r\nerror.\r\n\r\nOn success, deletes the task from the queue.\r\n\r\n#### queue.release(space, id [, delay [, ttl ] ])\r\n\r\nReturn a task back to the queue: the task is not executed.\r\nAdditionally, a new time to live and re-execution delay can be\r\nprovided.\r\n\r\n#### queue.requeue(space, id)\r\n\r\nReturn a task to the queue, the task is not executed. Puts\r\nthe task at the end of the queue, so that it's executed only\r\nafter all existing tasks in the queue are executed.\r\n\r\n#### queue.bury(space, id)\r\n\r\nMark a task as `buried`. This special status excludes\r\nthe task from the active list, until it's `dug up`.\r\nThis function is useful when several attempts to execute a task\r\nlead to a failure. Buried tasks can be monitored by the queue\r\nowner, and treated specially.\r\n\r\n#### queue.done(space, id, ...)\r\n\r\nMark a task as complete (`done`), but doesn't delete it.\r\nReplaces task data with the supplied fields.\r\n\r\n### Common functions (neither producer nor consumer).\r\n\r\n#### queue.dig(space, id)\r\n\r\n'Dig up' a buried task. Checks, that the task is buried.\r\nThe task status is changed to `ready`.\r\n\r\n#### queue.kick(space, tube [, count] )\r\n\r\n'Dig up' `count` tasks in a queue. If `count` is not given,\r\ndigs up just one buried task.\r\n\r\n#### queue.unbury(space, id)\r\n\r\nAn alias to `dig`.\r\n\r\n#### queue.delete(space, id)\r\n\r\nDelete a task from the queue (regardless of task state or status).\r\n\r\n#### queue.meta(space, id)\r\n\r\nReturn taks metadata:\r\n\r\n1. `id` (string) - task id\r\n1. `tube` (string) - queue id\r\n1. `status` (string) - task status\r\n1. `event` (time64) - time of the next important event in task\r\n   life time, for example, when `ttl` or `ttr` expires, in seconds\r\n   since start of the UNIX epoch\r\n1. `ipri` (string) - internal value of the task priority\r\n1. `pri` (string) - task priority as set when the task was added\r\n   to the queue\r\n1. `cid` (number) - consumer id, of the consumer which took the\r\n   task (only if the task is `taken`)\r\n1. `created` (time64) - time when the task was created (seconds\r\n   since start of the UNIX epoch).\r\n1. `ttl` (time64) - task time to live\r\n1. `ttr` (time64) - task time to run\r\n1. `cbury` (count) - how many times the task was buried\r\n1. `ctaken` (Ð§) - how many times the task was taken\r\n1. `now` (time64) - time recorded when the meta was called\r\n\r\n#### queue.peek(space, id)\r\n\r\nReturn a task by task id. Returned tuple has the following\r\nfields:\r\n\r\n1. `id` (string) - task identifier\r\n1. `tube` (string) - queue identifier\r\n1. `status` (string) - task status\r\n1. task data (all fields passed into `put`/`urgent` when\r\n   the task was created)\r\n\r\n#### queue.statistics()\r\n\r\nReturn queue module statistics, since server start.\r\nThe statistics is broken down by queue id. Only queues on which\r\nthere was some activity are included in the output.\r\n\r\nThe format of the statistics is a sequence of rows, where each\r\nodd row is the name of a statistical parameter, and the\r\nnext even row is its value.\r\n\r\n"}